/*
 * art-frame -- an artful sands image emulation
 *
 * Copyright (C) 2016, 2019 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint/art-frame>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include <status-line.hh>
#include <log.hh>
#include <QtWidgets/QMessageBox>
#include <QtWidgets/QApplication>
#include <main-window.hh>

QMessageBox *
Status_line::create_cool_message()
{
  QMessageBox *cool_message = new QMessageBox();
  if (!cool_message) {
    Log::fatal("Status_line::Status_line(): not enough memory");
  }
  QPalette palette;
  palette.setColor(QPalette::Window, Qt::yellow);
  /*
  palette.setColor(QPalette::WindowText, Qt::blue);
  palette.setColor(QPalette::ToolTipText, Qt::cyan);
  palette.setColor(QPalette::Text, Qt::green);
  palette.setColor(QPalette::BrightText, Qt::red);
  palette.setColor(QPalette::ButtonText, Qt::white);
  */
  cool_message->setPalette(palette);
  cool_message->setStandardButtons(0);
  cool_message->setWindowFlags(cool_message->windowFlags() |
                               Qt::FramelessWindowHint |
                               Qt::WindowStaysOnTopHint);
  QFont font = QFont();
  font.setPixelSize(32);
  font.setBold(true);
  cool_message->setFont(font);
  cool_message->setText(tr("CPU temperature too high.\n"
                           "Pausing simulation for a short while\n"
                           "for cooling down the CPU."));
  return cool_message;
}

void
Status_line::create_dialogs()
{
  _about_dialog = new About_dialog(this);
  if (!_about_dialog) {
    Log::fatal("Status_line::Status_line(): not enough memory");
  }
  _about_dialog->setModal(true);

  _license_dialog = new License_dialog(this);
  if (!_license_dialog) {
    Log::fatal("Status_line::Status_line(): not enough memory");
  }
  _license_dialog->setModal(true);

  _cool_message = create_cool_message();
}

void
Status_line::create_info_row()
{
  _info_row = new QWidget();
  if (!_info_row) {
    Log::fatal("Status_line::create_info_row(): not enough memory");
  }
  _layout->addWidget(_info_row);
  _info_row_layout = new QHBoxLayout();
  if (!_info_row_layout) {
    Log::fatal("Status_line::create_info_row(): not enough memory");
  }
  _info_row->setLayout(_info_row_layout);

  _sensors_display = new Sensors_display(this);
  if (!_sensors_display) {
    Log::fatal("Status_line::Status_line(): not enough memory");
  }
  _info_row_layout->addWidget(_sensors_display);

  _cpu_status_display = new Cpu_status_display(this);
  if (!_cpu_status_display) {
    Log::fatal("Status_line::Status_line(): not enough memory");
  }
  _info_row_layout->addWidget(_cpu_status_display);
  _info_row_layout->addStretch();

  _label_keys = new QLabel(tr("<h1>Interactive Art Frame</h1>"));
  if (!_label_keys) {
    Log::fatal("Status_line::Status_line(): not enough memory");
  }
  _label_keys->setTextFormat(Qt::RichText);
  _info_row_layout->addWidget(_label_keys);
}

void
Status_line::create_pixmap_and_icon(const char *image_path,
                                    QPixmap **pixmap,
                                    QIcon **icon)
{
  *pixmap = new QPixmap(image_path);
  if (!*pixmap) {
    Log::fatal("Status_line::create:icon(): not enough memory");
  }
  *icon = new QIcon(**pixmap);
  if (!*icon) {
    Log::fatal("Status_line::create_icon(): not enough memory");
  }
}

void
Status_line::create_button(QHBoxLayout *button_row_layout,
                           QPushButton **button,
                           const char *tool_tip,
                           QPixmap **pixmap,
                           const char *image_path,
                           QIcon **icon)
{
  create_pixmap_and_icon(image_path, pixmap, icon);
  *button = new QPushButton(/*tr(label)*/);
  if (!*button) {
    Log::fatal("Status_line::create_button(): not enough memory");
  }
  (*button)->setIcon(**icon);
  (*button)->setIconSize((*pixmap)->rect().size());
  (*button)->setToolTip(tr(tool_tip));
  button_row_layout->addWidget(*button);
}

void
Status_line::create_dial(QHBoxLayout *_button_row_layout,
                         QDial **dial,
                         const char *tool_tip, const double initial_value)
{
  *dial = new QDial();
  if (!*dial) {
    Log::fatal("Status_line::create_dial(): not enough memory");
  }
  (*dial)->setToolTip(tr(tool_tip));
  (*dial)->setValue((int)(initial_value * (*dial)->maximum()));
  _button_row_layout->addWidget(*dial);
}

void
Status_line::create_button_row()
{
  _button_row = new QWidget();
  if (!_button_row) {
    Log::fatal("Status_line::Status_line(): not enough memory");
  }

  _button_row_layout = new QHBoxLayout();
  if (!_button_row_layout) {
    Log::fatal("Status_line::Status_line(): not enough memory");
  }
  _button_row->setLayout(_button_row_layout);

  create_button(_button_row_layout,
                &_button_mode, "pause / resume",
                &_pixmap_pause, "pause.png", &_icon_pause);
  create_pixmap_and_icon("resume.png",
                         &_pixmap_resume, &_icon_resume);

  create_button(_button_row_layout,
                &_button_previous, "reset to previous image",
                &_pixmap_previous, "previous.png", &_icon_previous);

  create_button(_button_row_layout,
                &_button_reset, "reset current image",
                &_pixmap_reset, "reset.png", &_icon_reset);

  create_button(_button_row_layout,
                &_button_next, "reset to next image",
                &_pixmap_next, "next.png", &_icon_next);

  create_dial(_button_row_layout, &_dial_volume, "control volume", 0.5);

  create_button(_button_row_layout,
                &_button_mute, "mute / unmute",
                &_pixmap_unmuted, "unmuted.png", &_icon_unmuted);
  create_pixmap_and_icon("muted.png",
                         &_pixmap_muted, &_icon_muted);

  create_dial(_button_row_layout, &_dial_speed,
              "control speed of particles flow", 0.5);

  create_button(_button_row_layout,
                &_button_quit, "shut down system",
                &_pixmap_quit, "quit.png", &_icon_quit);

  create_button(_button_row_layout,
                &_button_about, "about this application",
                &_pixmap_about, "about.png", &_icon_about);
  _layout->addWidget(_button_row);
  _layout->addStretch();
}

Status_line::Status_line(QWidget *parent,
                         IParticles_change_listener *particles_change_listener,
                         const IConfig *config)
  : QWidget(parent)
{
  if (!parent) {
    Log::fatal("Status_line::Status_line(): parent is NULL");
  }
  _parent = parent;

  if (!particles_change_listener) {
    Log::fatal("Status_line::Status_line(): particles_change_listener is NULL");
  }
  _particles_change_listener = particles_change_listener;

  _simulation_control = 0;
  _transport_control = 0;

  _config_image_browser = new Config_image_browser(config);
  if (!_config_image_browser) {
    Log::fatal("Status_line::Status_line(): not enough memory");
  }

  QPalette background = palette();
  background.setColor(backgroundRole(), Qt::lightGray);
  setAutoFillBackground(true);
  setPalette(background);

  create_dialogs();

  _layout = new QVBoxLayout();
  if (!_layout) {
    Log::fatal("Status_line::Status_line(): not enough memory");
  }
  setLayout(_layout);

  create_info_row();
  create_button_row();

  adjustSize();

  _is_muted = false;
  _is_cooling = false;
  _is_running = false;
  _dial_volume->setEnabled(false);
  _dial_speed->setEnabled(false);
  gettimeofday(&_menue_button_last_pressed, NULL);

  create_actions();
}

Status_line::~Status_line()
{
  // Q objects will be deleted by Qt, just set them to 0
  _layout = 0;
  _tool_bar = 0;
  _label_keys = 0;
  _sensors_display = 0;
  _cpu_status_display = 0;
  _pixmap_resume = 0;
  _icon_resume = 0;
  _pixmap_pause = 0;
  _icon_pause = 0;
  _pixmap_previous = 0;
  _icon_previous = 0;
  _pixmap_reset = 0;
  _icon_reset = 0;
  _pixmap_next = 0;
  _icon_next = 0;
  _pixmap_unmuted = 0;
  _icon_unmuted = 0;
  _pixmap_muted = 0;
  _icon_muted = 0;
  _pixmap_quit = 0;
  _icon_quit = 0;
  _pixmap_about = 0;
  _icon_about = 0;
  _about_dialog = 0;
  _license_dialog = 0;
  _button_mode = 0;
  _button_previous = 0;
  _button_reset = 0;
  _button_next = 0;
  _dial_volume = 0;
  _button_mute = 0;
  _dial_speed = 0;
  _button_quit = 0;
  _button_about = 0;

  delete _config_image_browser;
  _config_image_browser = 0;
  _simulation_control = 0;
  _transport_control = 0;
  _parent = 0;
  _cool_message = 0;
  _is_muted = false;
  _is_running = false;
  _is_cooling = false;
  _menue_button_last_pressed.tv_sec = 0;
  _menue_button_last_pressed.tv_usec = 0;
}

void
Status_line::setVisible(const bool visible)
{
  setFixedWidth(_parent->geometry().width());
  QWidget::setVisible(visible);
}

void
Status_line::resizeEvent(QResizeEvent* event)
{
  setFixedWidth(_parent->geometry().width());
  QWidget::resizeEvent(event);
}

void
Status_line::set_simulation_control(ISimulation_control *simulation_control)
{
  if (!simulation_control) {
    Log::fatal("Status_line::set_simulation_control(): "
	       "simulation_control is NULL");
  }
  _simulation_control = simulation_control;
  _simulation_control->load_image(_config_image_browser->get_current_image());
  slot_speed_change();
}

ISimulation_control *
Status_line::get_simulation_control()
{
  return _simulation_control;
}

void
Status_line::set_transport_control(ITransport_control *transport_control)
{
  if (!transport_control) {
    Log::fatal("Status_line::set_transport_control(): "
	       "transport_control is NULL");
  }
  _transport_control = transport_control;
  slot_volume_change();
}

void
Status_line::create_actions()
{
  connect(_button_mode,
	  SIGNAL(clicked()),
	  this,
	  SLOT(slot_toggle_mode()));
  connect(_button_previous,
	  SIGNAL(clicked()),
	  this,
	  SLOT(slot_previous()));
  connect(_button_reset,
	  SIGNAL(clicked()),
	  this,
	  SLOT(slot_reset()));
  connect(_button_next,
	  SIGNAL(clicked()),
	  this,
	  SLOT(slot_next()));
  connect(_dial_volume,
	  SIGNAL(valueChanged(int)),
	  this,
	  SLOT(slot_volume_change()));
  connect(_button_mute,
	  SIGNAL(clicked()),
	  this,
	  SLOT(slot_toggle_mute()));
  connect(_dial_speed,
	  SIGNAL(valueChanged(int)),
	  this,
	  SLOT(slot_speed_change()));
  connect(_button_quit,
	  SIGNAL(clicked()),
	  this,
	  SLOT(slot_confirm_quit()));
  connect(_button_about,
	  SIGNAL(clicked()),
	  this,
	  SLOT(slot_show_about()));
}

void
Status_line::particles_changed()
{
  _particles_change_listener->particles_changed();
}

void
Status_line::keyPressEvent(QKeyEvent* event)
{
  const QString label = event->text();
  const int code = event->key();
  switch (code) {
    // TODO: Special keys like Qt::Key_Left and Qt::Key_Right are
    // already caught by QWidget parent class.  Need to change parent
    // class's key filtering policy for catching them in this switch
    // statement.
  case Qt::Key_Back:
  case Qt::Key_Left:
  case Qt::Key_P:
  case Qt::Key_Backtab:
    slot_previous();
    break;
  case Qt::Key_Forward:
  case Qt::Key_N:
  case Qt::Key_Right:
  case Qt::Key_Tab:
    slot_next();
    break;
  case Qt::Key_A:
  case Qt::Key_Info:
    _about_dialog->show();
    break;
  case Qt::Key_C:
    _license_dialog->show();
    break;
  case Qt::Key_L:
  case Qt::Key_Pause:
    slot_toggle_mode();
    break;
  case Qt::Key_M:
  case Qt::Key_VolumeMute:
    slot_toggle_mute();
    break;
  case Qt::Key_Q:
  case Qt::Key_Escape:
  case Qt::Key_PowerOff:
    slot_confirm_quit();
    break;
  case Qt::Key_R:
    slot_reset();
    break;
  case Qt::Key_MenuKB:
  case Qt::Key_F1:
  case Qt::Key_Question:
  case Qt::Key_NumberSign:
    setVisible(!isVisible());
    gettimeofday(&_menue_button_last_pressed, NULL);
    break;
  default:
    // no action
    break;
  }
};

void
Status_line::start_cooling_break()
{
  if (!_is_cooling) {
    if (!_simulation_control) {
      Log::fatal("Status_line::slot_start_cooling_break(): "
		 "_simulation_control is NULL");
    }
    if (!_cool_message) {
      Log::fatal("Status_line::slot_start_cooling_break(): "
		 "_cool_message is NULL");
    }
    setEnabled(false);
    _cool_message->show();
    if (_is_running) {
      _simulation_control->pause();
    } else {
      // already pausing because of user pause
    }
    _is_cooling = true;
  } else {
    // we are outside of the hystheresis => keep current state
  }
}

void
Status_line::stop_cooling_break()
{
  if (_is_cooling) {
    if (!_simulation_control) {
      Log::fatal("Status_line::slot_start_cooling_break(): "
		 "_simulation_control is NULL");
    }
    if (!_cool_message) {
      Log::fatal("Status_line::slot_start_cooling_break(): "
		 "_cool_message is NULL");
    }
    if (_is_running) {
      _simulation_control->resume();
    } else {
      // leave pausing because of user pause
    }
    _cool_message->hide();
    setEnabled(true);
    _is_cooling = false;
  } else {
    // we are outside of the hystheresis => keep current state
  }
}

const double
Status_line::STATUS_LINE_AUTO_HIDE_INTERVAL = 10; // [s]

void
Status_line::slot_auto_hide_status_line(const struct timeval mouse_last_moved)
{
  if (isVisible()) {
    struct timeval now;
    gettimeofday(&now, NULL);
    const time_t delta1_sec = now.tv_sec - mouse_last_moved.tv_sec;
    const time_t delta2_sec = now.tv_sec - _menue_button_last_pressed.tv_sec;
    if ((delta1_sec >= STATUS_LINE_AUTO_HIDE_INTERVAL) &&
	(delta2_sec >= STATUS_LINE_AUTO_HIDE_INTERVAL)) {
      setVisible(false);
    }
  }
}

void
Status_line::resume()
{
  _simulation_control->resume();
  _transport_control->resume();
  //_button_mode->setText(tr("Pause"));
  _button_mode->setIcon(*_icon_pause);
  _button_mode->setIconSize(_pixmap_pause->rect().size());
  //_button_previous->setEnabled(true);
  //_button_reset->setEnabled(true);
  //_button_next->setEnabled(true);
  _dial_volume->setEnabled(true);
  _dial_speed->setEnabled(true);
  _is_running = true;
}

void
Status_line::pause()
{
  _transport_control->pause();
  _simulation_control->pause();
  //_button_mode->setText(tr("Resume"));
  _button_mode->setIcon(*_icon_resume);
  _button_mode->setIconSize(_pixmap_resume->rect().size());
  //_button_previous->setEnabled(false);
  //_button_reset->setEnabled(false);
  //_button_next->setEnabled(false);
  _dial_volume->setEnabled(false);
  _dial_speed->setEnabled(false);
  _is_running = false;
}

void
Status_line::slot_toggle_mode()
{
  if (!_simulation_control) {
    Log::fatal("Status_line::slot_toggle_mode(): _simulation_control is NULL");
  }
  if (!_transport_control) {
    Log::fatal("Status_line::slot_toggle_mode(): _transport_control is NULL");
  }
  if (!_is_cooling) {
    if (_is_running) {
      pause();
    } else {
      resume();
    }
  } else {
    // can not change running state during cooling break
  }
}

void
Status_line::slot_previous()
{
  if (!_simulation_control) {
    Log::fatal("Status_line::slot_previous(): _simulation_control is NULL");
  }
  _config_image_browser->move_to_previous_image();
  _simulation_control->load_image(_config_image_browser->get_current_image());
  particles_changed();
}

void
Status_line::slot_reset()
{
  if (!_simulation_control) {
    Log::fatal("Status_line::slot_reset(): _simulation_control is NULL");
  }
  _simulation_control->reset_image();
  particles_changed();
}

void
Status_line::slot_next()
{
  if (!_simulation_control) {
    Log::fatal("Status_line::slot_next(): _simulation_control is NULL");
  }
  _config_image_browser->move_to_next_image();
  _simulation_control->load_image(_config_image_browser->get_current_image());
  particles_changed();
}

void
Status_line::slot_confirm_quit()
{
  QMessageBox::StandardButton reply;
  reply = QMessageBox::question(this, tr("Confirm Shutdown"),
				tr("Are you sure to shut down the system?"),
                                QMessageBox::Yes | QMessageBox::No);
  if (reply == QMessageBox::Yes) {
    QApplication::quit();
  } else {
    // continue
  }
}

void
Status_line::slot_show_about()
{
  _about_dialog->show();
}

void
Status_line::slot_volume_change()
{
  if (!_transport_control) {
    Log::fatal("Status_line::slot_volume_change(): _transport_control is NULL");
  }
  const double value =
    ((double)_dial_volume->value()) /
    (_dial_volume->maximum() - _dial_volume->minimum());
  _transport_control->set_volume(value);
}

void
Status_line::slot_toggle_mute()
{
  if (!_transport_control) {
    Log::fatal("Status_line::slot_toggle_mute(): _transport_control is NULL");
  }
  if (_is_muted) {
    _transport_control->unmute();
    //_button_mute->setText(tr("Mute"));
    _button_mute->setIcon(*_icon_unmuted);
    _button_mute->setIconSize(_pixmap_unmuted->rect().size());
    _is_muted = false;
  } else {
    _transport_control->mute();
    //_button_mute->setText(tr("Unmute"));
    _button_mute->setIcon(*_icon_muted);
    _button_mute->setIconSize(_pixmap_muted->rect().size());
    _is_muted = true;
  }
}

void
Status_line::slot_speed_change()
{
  if (!_simulation_control) {
    Log::fatal("Status_line::slot_speed_change(): _simulation_control is NULL");
  }
  const double value =
    ((double)_dial_speed->value()) /
    (_dial_speed->maximum() - _dial_speed->minimum());
  _simulation_control->set_speed(value);
}

void
Status_line::slot_update_sensors_display(const double pitch,
					 const double roll,
					 const double ax,
					 const double ay,
					 const double temperature)
{
  _sensors_display->slot_update(pitch, roll, ax, ay);
  _cpu_status_display->slot_update_case_temperature(temperature);
}

void
Status_line::slot_update_cpu_status_display(const double vc_temperature)
{
  _cpu_status_display->slot_update_cpu_temperature(vc_temperature);
}

/*
 * Local variables:
 *   mode: c++
 *   coding: utf-8
 * End:
 */
