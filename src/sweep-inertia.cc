/*
 * art-frame -- an artful sands image emulation
 *
 * Copyright (C) 2016, 2019 JÃ¼rgen Reuter
 *
 * This file is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it
 * under the same distribution terms that you use for the rest of that
 * program.
 *
 * For updates and more info or contacting the author, visit:
 * <https://github.com/soundpaint/art-frame>
 *
 * Author's web site: www.juergen-reuter.de
 */

#include <sweep-inertia.hh>
#include <cmath>
#include <log.hh>

Sweep_inertia::Sweep_inertia(const uint16_t width, const uint16_t height,
                             const IConfig *config)
{
  _width = width;
  _height = height;
  const uint32_t size = _width * _height;

  if (!config) {
    Log::fatal("Sweep_inertia::Sweep_inertia(): config is NULL");
  }
  _config = config;

  _inertia = new inertia_t[size];
  if (!_inertia) {
    Log::fatal("Sweep_inertia::Sweep_inertia(): not enough memory");
  }
  for (uint32_t index = 0; index < size; index++) {
    _inertia[index].x = 0.0;
    _inertia[index].y = 0.0;
  }
}

Sweep_inertia::~Sweep_inertia()
{
  _width = 0;
  _height = 0;
  memset(_inertia, 0, _width * _height * sizeof(inertia_t));
  delete[] _inertia;
  _inertia = 0;
  _config = 0;
}

double *
Sweep_inertia::envelope = 0;

const double
Sweep_inertia::get_envelope(const int16_t envelope_index,
                            const double peak_sensitivity)
{
  const int sweep_width = _config->get_sweep_width();
  const int center_index = sweep_width;
  if (!envelope) {
    envelope = new double[2 * sweep_width + 1];
    if (!envelope) {
      Log::fatal("Sweep_inertia::get_envelope(): not enough memory");
    }
    envelope[center_index] = peak_sensitivity;
    for (uint16_t index = 1; index <= sweep_width; index++) {
      const double sensitivity = peak_sensitivity / sqrt(1.0 + index * index);
      envelope[center_index + index] = sensitivity;
      envelope[center_index - index] = sensitivity;
    }
  }
  if (envelope_index < -sweep_width) {
    Log::fatal("Sweep_inertia::get_envelope(): "
               "envelope_index < -sweep_width");
  }
  if (envelope_index > +sweep_width) {
    Log::fatal("Sweep_inertia::get_envelope(): "
               "envelope_index > +sweep_width");
  }
  return envelope[center_index + envelope_index];
}

void
Sweep_inertia::add_horizontal_sweep(const uint32_t x0,
                                    const uint32_t y0,
                                    const uint32_t x1,
                                    const uint32_t y1,
                                    const struct inertia_t inertia)
{
  if (x1 < x0) {
    std::stringstream msg;
    msg << "Sweep_inertia::add_horizontal_sweep(): "
      "x1 < x0: " << x1 << " < " << x0;
    Log::fatal(msg.str());
  }
  const double sensitivity = _config->get_sweep_sensitivity();
  const int sweep_width = _config->get_sweep_width();
  const int32_t dx = x1 - x0;
  const int32_t dy = y1 - y0;
  for (uint32_t x = x0; x < x1; x++) {
    const uint32_t y = y0 + round(((double)(x - x0)) / dx * dy);
    if (y >= _height) {
      std::stringstream msg;
      msg << "Sweep_inertia::add_horizontal_sweep(): "
        "y >= height: " << y << " >= " << _height <<
        "(x0=" << x0 << ", y0=" << y0 << ", x=" << x <<
        ", dx=" << dx << ", dy=" << dy << ")";
      Log::fatal(msg.str());
    }
    for (int16_t envelope_index = -sweep_width;
         envelope_index <= +sweep_width; envelope_index++) {
      const int32_t ty = y + envelope_index;
      if ((ty >= 0) && (ty < _height)) {
        const double envelope = get_envelope(envelope_index, sensitivity);
        _inertia[ty * _width + x].x += inertia.x * envelope;
        _inertia[ty * _width + x].y += inertia.y * envelope;
      }
    }
  }
}

void
Sweep_inertia::add_vertical_sweep(const uint32_t x0,
                                  const uint32_t y0,
                                  const uint32_t x1,
                                  const uint32_t y1,
                                  const struct inertia_t inertia)
{
  if (y1 < y0) {
    std::stringstream msg;
    msg << "Sweep_inertia::add_horizontal_sweep(): "
      "y1 < y0: " << y1 << " < " << y0;
    Log::fatal(msg.str());
  }
  const double sensitivity = _config->get_sweep_sensitivity();
  const int sweep_width = _config->get_sweep_width();
  const int32_t dx = x1 - x0;
  const int32_t dy = y1 - y0;
  for (uint32_t y = y0; y < y1; y++) {
    const uint32_t x = x0 + round(((double)(y - y0)) / dy * dx);
    if (x >= _width) {
      std::stringstream msg;
      msg << "Sweep_inertia::add_vertical_sweep(): "
        "x >= width: " << x << " >= " << _width <<
        "(x0=" << x0 << ", y0=" << y0 << ", y=" << y <<
        ", dx=" << dx << ", dy=" << dy << ")";
      Log::fatal(msg.str());
    }
    for (int16_t envelope_index = -sweep_width;
         envelope_index <= +sweep_width; envelope_index++) {
      const int32_t tx = x + envelope_index;
      if ((tx >= 0) && (tx < _width)) {
        const double envelope = get_envelope(envelope_index, sensitivity);
        _inertia[y * _width + tx].x += inertia.x * envelope;
        _inertia[y * _width + tx].y += inertia.y * envelope;
      }
    }
  }
}

void
Sweep_inertia::add_sweep(const QPointF pos0,
                         const QPointF pos1,
                         const double time)
{
  double clipped_time;
  if (time < 0.01) {
    clipped_time = 0.01;
  } else if (time > 10.0) {
    clipped_time = 10.0;
  } else {
    clipped_time = time;
  }
  const double speed = 10.0 / clipped_time;
  const int32_t sx0 = round(pos0.x());
  const int32_t sy0 = round(pos0.y());
  const int32_t sx1 = round(pos1.x());
  const int32_t sy1 = round(pos1.y());

  // clip coordinates to rectangle (0, 0, _width, _height)
  const uint32_t x0 = (sx0 > 0) ? (sx0 < _width ? sx0 : _width - 1) : 0;
  const uint32_t y0 = (sy0 > 0) ? (sy0 < _height ? sy0 : _height - 1) : 0;
  const uint32_t x1 = (sx1 > 0) ? (sx1 < _width ? sx1 : _width - 1) : 0;
  const uint32_t y1 = (sy1 > 0) ? (sy1 < _height ? sy1 : _height - 1) : 0;
  if (x0 >= _width) {
    std::stringstream msg;
    msg << "Sweep_inertia::add_sweep(): "
      "x0 >= width: " << x0 << " >= " << _width;
    Log::fatal(msg.str());
  }
  if (x1 >= _width) {
    std::stringstream msg;
    msg << "Sweep_inertia::add_sweep(): "
      "x1 >= width: " << x1 << " >= " << _width;
    Log::fatal(msg.str());
  }
  if (y0 >= _height) {
    std::stringstream msg;
    msg << "Sweep_inertia::add_sweep(): "
      "y0 >= height: " << y0 << " >= " << _height;
    Log::fatal(msg.str());
  }
  if (y1 >= _height) {
    std::stringstream msg;
    msg << "Sweep_inertia::add_sweep(): "
      "y1 >= height: " << y1 << " >= " << _height;
    Log::fatal(msg.str());
  }
  const int32_t dx = x1 - x0;
  const int32_t dy = y1 - y0;
  const double sweep_length = sqrt((double)(dx * dx + dy * dy));
  if (sweep_length > 0.0) {
    struct inertia_t inertia0, inertia1;
    inertia0.x = speed * dx / sweep_length;
    inertia0.y = speed * dy / sweep_length;
    inertia1.x = -inertia0.x;
    inertia1.y = -inertia0.y;
    if (abs(dx) > abs(dy)) {
      if (x1 >= x0) {
        add_horizontal_sweep(x0, y0, x1, y1, inertia0);
      } else {
        add_horizontal_sweep(x1, y1, x0, y0, inertia1);
      }
    } else {
      if (y1 >= y0) {
        add_vertical_sweep(x0, y0, x1, y1, inertia0);
      } else {
        add_vertical_sweep(x1, y1, x0, y0, inertia1);
      }
    }
  } else {
    // zero length move => ignore
  }
}

void
Sweep_inertia::fade_step()
{
  const double fade_factor = _config->get_sweep_fade_factor();
  struct inertia_t *ptr_inertia = _inertia;
  for (int y = 0; y < _height; y++) {
    for (int x = 0; x < _width; x++) {
      ptr_inertia->x *= fade_factor;
      ptr_inertia->y *= fade_factor;
      ptr_inertia++;
    }
  }
}

const double
Sweep_inertia::get_inertia_x(const uint32_t pos_x, const uint32_t pos_y) const
{
  const double inertia = _inertia[pos_y * _width + pos_x].x;
  return inertia;
}

const double
Sweep_inertia::get_inertia_y(const uint32_t pos_x, const uint32_t pos_y) const
{
  const double inertia = _inertia[pos_y * _width + pos_x].y;
  return inertia;
}

/*
 * Local variables:
 *   mode: c++
 *   coding: utf-8
 * End:
 */
